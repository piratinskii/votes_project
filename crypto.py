import os
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes, serialization
import base64


# Функция генерации случайно мастер-фразу для ZKP
def generate_phrase():
    """
    Мы генерируем случайные 32 байта - некая строка, которая будет использоваться в качестве мастер-фразы.
    Мастер фраза необходима нам для реализации ZKP (подтверждение с нулевым знанием). Что это значит?
    Это значит, что мы можем доказать, что проголосовали (или что имеем право голосовать в целом) при этом не
    раскрывая никакой другой информации (за кого мы голосовали, например).
    Подробнее про нашу реализацию будет написано в функции to_vote (файл интерфейс).
    """
    phrase = os.urandom(32)
    return str(phrase)


# Функция генерации ключей для шифрования голосов
def generate_keys():
    """
    В нашей системе мы используем асимметричное шифрование. Это значит, что у нас есть два ключа - публичный и
    приватный. Публичный ключ используется для шифрования данных, а приватный - для расшифровки.
    Шифрование используется для того, чтобы никто не мог узнать, за кого мы проголосовали, а также для того, чтобы
    никто не мог подменить наш голос - ведь если мы будем использовать публичный ключ для шифрования, то только
    приватный ключ сможет расшифровать данные (он не хранится в базе данных, а хранится только у нас).
    Шифрование происходит с помощью алгоритма RSA (Rivest, Shamir и Adleman).
    """
    private_key = rsa.generate_private_key(  # Генерация приватного ключа
        public_exponent=65537,  # Public exponent - это число, которое используется в алгоритме RSA
        key_size=2048,  # Key size - это размер ключа в битах
        backend=default_backend()  # Backend - это библиотека, которая используется для генерации ключей
    )
    public_key = private_key.public_key()  # Генерация публичного ключа на основе приватного
    return public_key, private_key


# Функции сериализация приватных и публичных ключей
def serialize_private_key(private_key):
    """
    Сериализация - это процесс преобразования объекта в поток байтов, который может быть сохранен в файле или
    передан по сети. В нашем случае мы сериализуем приватный ключ в формате PEM (Privacy Enhanced Mail).

    Если простыми словами - нам необходимо преобразовать сгенерированный приватный ключ в строку, чтобы мы могли
    сохранить его в базе данных и в дальнейшем использовать для расшифровки голосов.
    """
    return private_key.private_bytes(
        encoding=serialization.Encoding.PEM,  # Формат кодирования - PEM (стандартный формат для таких ключей)
        format=serialization.PrivateFormat.PKCS8,  # Формат самого ключа - PKCS8
        encryption_algorithm=serialization.NoEncryption()
    )


def serialize_public_key(public_key):
    """
    Аналогичная функция для публичного ключа. Они имеют разный формат сериализации (приватный ключ - PKCS8, а
    публичный - SubjectPublicKeyInfo) - это стандартные форматы для таких ключей. Также мы используем кодировку
    PEM (аналогично приватному ключу).
    """
    return public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    ).decode()


def sign_results(results, private_key):
    """
    Для реализации требования о невозможности подмены результатов голосования (и возможности это доказать для всех
    сторон) мы используем подпись. Подпись - это некая строка, которая генерируется на основе данных, которые мы
    хотим подписать, и приватного ключа. При этом, чтобы подпись была надежной, нам необходимо использовать
    алгоритм хэширования (в нашем случае SHA256). Хэширование - это процесс преобразования данных в некую строку
    фиксированной длины (в нашем случае 256 бит). При этом, если мы хотим подписать данные, то нам необходимо
    сначала их хэшировать, а затем уже подписывать.

    По факту это очень похоже на то, что мы шифруем данные, но для шифрования мы бы использовали публичный ключ, при
    этом прочитать данные можно только с приватным ключем. Здесь же для подписи, наоборот, используется приватный ключ
    (который никто не знает), при этом проверить подпись можно только с помощью публичного ключа (который доступен всем).
    Таким образом мы можем доказать, что данные были подписаны именно нами, а не кем-то другим и не были изменены.
    На выходе из функции мы получим отдельную строку-подпись, сами данные останутся незашифрованными.

    В случае, если злоумышленник сможет попасть в Базу данных и поменяет значение результатов голосования, то
    подпись не совпадет с данными, которые мы получим из Базы данных, и мы сможем это доказать.
    """
    try:
        # Создание подписи
        signature = private_key.sign(
            results.encode(),
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        # Возвращаем подпись в формате base64 для удобства
        return base64.b64encode(signature).decode()
    except:
        return None


def verify_signature(results, signature, public_key):
    """
    Теперь функция для подтверждения подписи. Это обратная предыдущей функции функция. Мы передаем в нее данные,
    подпись и публичный ключ, а она возвращает True, если подпись верна, и False, если нет.

    Таким образом, если данные никто не поменял и они были подписаны правильным приватным ключом (который соответствует
    публичному ключу, который мы передаем в функцию) - то функция вернет True, в случае какого-либо нарушения - False.
    Это и есть доказательство того, что результаты действительны и не были подменены.
    """
    try:
        # Декодирование подписи из формата base64
        signature_bytes = base64.b64decode(signature)
        # Верификация подписи
        public_key.verify(
            signature_bytes,
            results.encode(),
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        return True
    except:
        return False


# Функции шифрования и расшифровки голосов
def encrypt_vote(vote, public_key):
    """
    Функция шифрования ключа. Как говорилось выше (в функции generate_keys), для шифрования используется публичный
    ключ, а для расшифровки - приватный. Таким образом, мы шифруем голос с помощью публичного ключа, а расшифровываем
    с помощью приватного. При этом, чтобы шифрование было надежным, мы используем алгоритм OAEP (Optimal Asymmetric
    Encryption Padding) - нам нужно учитывать, что если мы будем шифровать голос стандартными методами он каждый раз
    будет выглядеть одинаково и злоумышленник по внешнему виду сможет понять за кого был отдан голос. Поэтому мы
    используем OAEP - это алгоритм, который добавляет к нашим данным некоторые случайные данные, чтобы шифр каждый раз
    выглядел по-разному. Таким образом, злоумышленник не сможет понять за кого был отдан голос, даже если он получит
    доступ к Базе данных. Этот процесс называется "заполнение" (добавление случайных данных к шифруемым данным).
    """
    try:
        encrypted_vote = public_key.encrypt(
            str(vote).encode(),
            padding.OAEP(  # Заполнение OAEP
                mgf=padding.MGF1(algorithm=hashes.SHA256()),  # Алгоритм заполнения - MGF1
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        """
        Мы используем base64 для того, чтобы закодировать наш шифр в строку, которую можно будет записать в Базу данных.
        По факту это приведение формата данных к строке, чтобы мы могли записать его в Базу данных.
        """
        return base64.b64encode(encrypted_vote).decode()
    except:
        return None


def decrypt_vote(encrypted_vote, private_key):
    """
    Зашифрованный с помощью публичного ключа голос можно расшифровать только с помощью соответствующего приватного ключа.
    Мы передаем в функцию зашифрованные данные и приватный ключ, а она возвращает расшифрованные данные.
    """
    try:
        decoded_vote = base64.b64decode(encrypted_vote)  # Декодирование из формата base64
        decrypted_vote = private_key.decrypt(
            decoded_vote,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        return decrypted_vote.decode()
    except:
        return None
