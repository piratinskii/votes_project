## Авторы
* Пиратинский Евгений - 342540374
* Эдельман Валентина - 346571284
* Гринбаум Саша - 345982755

## Описание проекта
- Проект реализации системы голосование, с использованием различных криптографических практик.
- Система предполагает, что у нас есть избиратели, и есть центры, которые осуществляют подсчет. 
(Использование множества центров подсчета голосов призвано обеспечить анонимность избирателей и предотвратить сговор нескольких центров с целью
подсчета результатов голосования). Будем считать, что избирателям предоставляется выбор только одного из двух кандидатов. Чтобы избежать политических
дискуссий, предположим, что у нас есть политическая система США, в которой единственными кандидатами являются демократы
или республиканцы.
## Система голосования должна обладать следующими свойствами:
### 1. Голосовать смогут только уполномоченные избиратели 
Реализовано с помощью ZKP с использованием пары приватного и публичного ключа - RSA-шифрование). 
В нашем проекте мы шифруем некую "мастер-фразу" с помощью публичного ключа (приглашение на выборы), и декодируем ее с помощью приватного ключа (ключ-карта для совершения выбора).
Таким образом голосовать могут только уполномоченные избиратели, которые находятся в базе данных, имеют действительный публичный ключ, 
который также хранится в базе данных, и имеют действительный приватный ключ, который хранится в их личном файле)
### 2. Никто не сможет проголосовать более одного раза 
Реализовано также с помощью ZKP с использованием пары приватного и публичного ключа - RSA-шифрование). Когда человек отдает свой голос
он проверяется на право голосования с помощью шифровки и дешифровки мастер-фразы. Если человек уже голосовал, то зашифрованная мастер-фраза
хранится в базе данных, и при попытке проголосовать повторно он не сможет этого сделать, так как сработает проверка на наличие зашифрованной мастер-фразы в базе данных.
При этом, в случае если третье лицо попытается воспрепятствовать его голосу записав в базу данных зашифрованную другим-ключом мастер-фразу (или любую другую информацию) - 
дешифровка этой мастер-фразы с помощью приватного ключа не даст никакой информации, так как она была зашифрована другим ключом - а значит мы сможем подтвердить, что
человек ещё не голосовал, и он сможет отдать свой голос.
### 3. Ни одна заинтересованная сторона не сможет определить, как проголосовал кто-то другой.
Реализовано с помощью RSA-шифрования. Каждый голос шифруется с помощью публичного ключа избирательного центра и может быть расшифрован
только соответствующим приватным ключом. При этом в базе данных напрямую не хранится соответствие "проголосовавший - голос" - только сам выбранный кандидат.
Кроме того, для того, чтобы при получении третьими лицами доступа к БД невозможно было понять по внешнему виду зашифрованных
ключей распределение голосов мы используем OAEP - это алгоритм, который добавляет к нашим данным некоторые случайные данные, чтобы шифр каждый раз
выглядел по-разному. Таким образом, злоумышленник не сможет понять за кого был отдан голос, даже если он получит
доступ к Базе данных. Этот процесс называется "заполнение" (добавление случайных данных к шифруемым данным).
### 4. Никто не может дублировать чужой голос.
Так как реализован пункт 2, то никто не сможет проголосовать за человека повторно. Также ввиду реализации третьего пункта 
простое "дублирование" голоса в БД не имеет никакого смысла, так как в БД хранится только зашифрованный голос с заполнением, а не соответствие "голос - проголосовавший".
### 5. Окончательный результат будет рассчитан правильно.
Реализовано с помощью всех вышеперечисленных функций. При подсчете голосов проверяется все описанные варианты вмешательств,
каждый центр подсчета голосов имеет свой приватный ключ, который неизвестен никому, кроме него самого, и при подсчете голосов
происходит расшифровка голосов с помощью этого приватного ключа, и подсчет голосов. При этом, если кто-то попытается подсчитать голоса
с помощью другого приватного ключа, то он получит неверный результат, так как голоса будут расшифрованы неверно.
### 6. Все заинтересованные стороны смогут убедиться, что результат был рассчитан правильно.
Реализовано с помощью цифровой подписи (RSA-шифрование). 
Это криптографический механизм, который позволяет создать "подпись" для данных с использованием приватного ключа. Эта подпись затем может быть проверена любым, 
у кого есть соответствующий публичный ключ, чтобы убедиться в целостности данных и подлинности отправителя. Таким образом, в случае изменения результатов напрямую
в БД, либо при попытке подделать подпись - мы сможем увидеть, что результат был подделан, так как подпись будет неверной.
Смотри функцию check_votes() в файле interface.py
### 7. Протокол будет работать даже в присутствии плохих сторон (третьих лиц, которые могут вмешиваться в процесс голосования – ПЛОХИХ ПАРНЕЙ).
Реализовано с помощью всех вышеперечисленных функций. Для удобства проверки реализован интерфейс thirdparty.py - SQL-запросы к БД (если третьи лица взломали БД)

## Описание файлов
### 1. interface.py 
Файл с основными функциями для работы программы
#### 1.1. execute_query() 
Выполняет SQL-запрос и возвращает результат 
#### 1.2. clear_console() 
Функция "для красоты". Очищает консоль
#### 1.3. error(message) 
Функция для форматирование ошибок. Принимает текст ошибки - возвращает rich-панель с этой ошибкой
#### 1.4. list_of_tally_centers() 
Возвращает список всех избирательных центров
#### 1.5. list_of_candidates() 
Возвращает список всех кандидатов
#### 1.6. get_voter(passport) 
Возвращает избирателя по его паспорту
#### 1.7. get_tally_center(tally_center_id) 
Возвращает избирательный центр по его id
#### 1.8. to_vote(passport, private_key_serialized, candidate_id, tally_center_id) 
Функция для голосования. Принимает номер паспорта голосующего, приватный ключ (в сериализованном виде), id кандидата и id избирательного центра
#### 1.9. tally_votes(tally_center_id, tally_center_private_key) 
Функция для подсчета голосов. Принимает id избирательного центра и его приватный ключ. Проводит необходимые проверки, подсчет голосов, записывает результат в таблицу "tally_results" и подписывает результат цифровой подписью с помощью своего приватного ключа
#### 1.10. check_votes() 
Эта функция сразу выполняет несколько ролей: для начала она возвращает нам в удобном виде результаты голосования
по каждому участку. Также она проверяет подписи участков и возвращает результат проверки, а значит предотвращает
изменения результатов голосования в БД
#### 1.11. print_votes() 
Функция для вывода результатов голосования в консоль в простом текстовом виде (для проведения симуляции)
### 2. database.py 
Файл настроек БД SQLLite. Содержит в себе одну функцию - db_setup() для создания таблиц в БД, согласно схемам
### 3. db_generator.py
Файл для генерации данных в БД. Содержит в себе функцию data_generation(), которая заполняет БД случайными и предустановленными данными.
Имена и Фамилии голосующих генерируется случайно на основе двух списков, затем голосующие получают случайные номера паспортов,
генерируется публичные и приватные ключи для пользователя (вторые хранятся по пути user_keys/ для нашего удобства тестирования, в реальной системе они должны быть только у пользователя)
Кандидаты генерируются из списка (согласно заданию это Демократы и Республиканцы), участки генерируются в зависимости от настроек
(по умолчанию - 5 участков с именами "Tally center №{id участка}"). Кроме того, в этом файле также генерируется файл с мастер-фразой для 
реализации ZKP (случайный набор байтов, подробнее смотри в функции generate_phrase в файле crypto.py)
### 4. crypto.py
Файл с функциями для криптографии
#### 4.1. generate_phrase()
Генерация мастер-фразы для реализации ZKP. Представляет собой 32 случайных байта, которые должны быть уникальны и хранится 
только у проверяющей системы.
#### 4.2. generate_keys()
Генерация публичного и приватного ключей (пользователей и избирательных центров). Возвращает публичный и приватный ключи.
#### 4.3. serialize_private_key(private_key)
Функция для сериализации приватного ключа. Возвращает поток байт, который может быть сохранен в файле
#### 4.4. serialize_public_key(public_key)
Аналогичная функция сериализации публичного ключа
#### 4.5. sign_results(results, private_key)
Функция цифровой подписи результатов голосования с помощью приватного ключа центров подсчета голосов. Возвращает подпись 
в формате base64 (для удобства хранения в БД). Реализована с помощью RSA
#### 4.6. verify_signature(results, signature, public_key)
Функция для проверки подписи. Принимает результаты голосования, подпись и публичный ключ. Возвращает True, если подпись и результаты подлинны,
и False в случае если подпись или результаты были изменены. Реализована с помощью RSA
### 4.7. encrypt_vote(vote, public_key)
Функция для шифрования голоса. Принимает голос и публичный ключ. Возвращает зашифрованный голос в формате base64 (для удобства хранения в БД). Реализована с помощью RSA
c применением паддинга OAEP (заполнение случайными данные для предотвращения атаки по внешнему сходству шифров)
### 4.8. decrypt_vote(encrypted_vote, private_key)
Функция для расшифровки голоса. Принимает зашифрованный голос и приватный ключ. Возвращает расшифрованный голос.
## 5. simulation.py
Файл с реализацией симуляции голосования, содержащий в себе одну единственную функцию - voting_simulation(), которая поочередно
проходит все этапы голосования (сначала за каждого голосующего, а потом за каждый центр подсчета голосов)
## 6. main.py
Файл с реализацией основной логики программы. Удаляет текущую БД, удаляет текущие приватные ключи и создает БД заново
(см пункт 2), после чего заполняет её случайными данными (см пункт 3), а затем проводит на основе этих данных симуляцию голосования
(см пункт 5). Запускается отдельно.
## 7. voter_interface.py
Интерфейс для голосующих. Представляет собой консольное приложение, с простой графикой и удобным интерфейсом для того, чтобы
отдать свой голос. Содержит одну функцию - menu() - для вывода, ввода и обработки всей необходимой информации. Запускается отдельно.
## 8. tally_interface.py
Интерфейс для центров подсчета голосов. Представляет собой консольное приложение, с простой графикой и удобным интерфейсом для того, чтобы
подсчитать голоса и вывести результаты голосования (после подсчета голосов всеми центрами). Запускается отдельно
### 8.1 display_results(final_results) 
Вывод результатов голосования по каждому центру в отдельности, а также общие результаты голосования в табличном виде с помощью
библиотеки rich
### 8.2 menu()
Основная функция интерфейса, для вывода, ввода и обработки всей информации.
## 9. thirdparty.py
Файл "третьих лиц". Представляет собой консольное приложение, с простой графикой и удобным интерфейсом для того, чтобы
напрямую писать запросы к БД и получать от неё ответы. Запускается отдельно.
### 9.1 query(sql)
Выполняет запрос к БД, возвращает результат в случае успеха, в случае ошибки возвращает текст этой ошибки в форматированном
виде (см пункт 1.3)
### 9.2 menu()
Основная функция интерфейса, для вывода, ввода и обработки всей информации.